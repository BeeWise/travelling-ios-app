//
//  ExploreViewController+DisplayLogic.swift
//  Travelling
//
//  Created by Dimitri Strauneanu on 13/09/2020.
//  Copyright (c) 2020 Travelling. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ExploreDisplayLogic: class {
    func displayWillFetchItems()
    func displayDidFetchItems()
    
    func displayItems(viewModel: ExploreModels.ItemsPresentation.ViewModel)
    
    func displayNoMoreItems(viewModel: ExploreModels.NoMoreItemsPresentation.ViewModel)
    func displayRemoveNoMoreItems()
    
    func displayEmptyState(viewModel: ExploreModels.EmptyStatePresentation.ViewModel)
    func displayRemoveEmptyState()
    
    func displayErrorState(viewModel: ExploreModels.ErrorStatePresentation.ViewModel)
    func displayRemoveErrorState()
    
    func displayWillFetchImage(viewModel: ExploreModels.ImageFetching.ViewModel)
    func displayDidFetchImage(viewModel: ExploreModels.ImageFetching.ViewModel)
    func displayImage(viewModel: ExploreModels.ImagePresentation.ViewModel)
}

extension ExploreViewController: ExploreDisplayLogic {
    func displayWillFetchItems() {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].isLoading = true
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayDidFetchItems() {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].isLoading = false
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayItems(viewModel: ExploreModels.ItemsPresentation.ViewModel) {
        DispatchQueue.main.async {
            self.tableView?.performBatchUpdates({
                let section = ExploreModels.SectionIndex.items.rawValue
                let index = self.sections[section].items.count
                let indexPaths = viewModel.displayedItems.enumerated().map({ IndexPath(row: index + $0.offset, section: section) })
                self.sections[section].items.append(contentsOf: viewModel.displayedItems)
                self.tableView?.insertRowsWithoutAnimation(at: indexPaths)
            }, completion: nil)
        }
    }
    
    func displayNoMoreItems(viewModel: ExploreModels.NoMoreItemsPresentation.ViewModel) {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].noMoreItemsText = viewModel.text
            self.sections[section].noMoreItems = true
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayRemoveNoMoreItems() {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].noMoreItemsText = nil
            self.sections[section].noMoreItems = false
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayEmptyState(viewModel: ExploreModels.EmptyStatePresentation.ViewModel) {
        DispatchQueue.main.async {
            self.tableView?.backgroundView = self.emptyStateView(image: viewModel.image, attributedText: viewModel.text)
        }
    }
    
    func displayRemoveEmptyState() {
        DispatchQueue.main.async {
            self.tableView?.backgroundView = nil
        }
    }
    
    func displayErrorState(viewModel: ExploreModels.ErrorStatePresentation.ViewModel) {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].errorText = viewModel.text
            self.sections[section].hasError = true
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayRemoveErrorState() {
        DispatchQueue.main.async {
            let section = ExploreModels.SectionIndex.footer.rawValue
            self.sections[section].errorText = nil
            self.sections[section].hasError = false
            self.tableView?.reloadSectionsWithoutAnimation(sections: IndexSet(integer: section))
        }
    }
    
    func displayWillFetchImage(viewModel: ExploreModels.ImageFetching.ViewModel) {
        DispatchQueue.main.async {
            viewModel.item.isLoadingImage = true
            viewModel.item.cellInterface?.setIsLoadingImage(isLoading: true)
        }
    }
    
    func displayDidFetchImage(viewModel: ExploreModels.ImageFetching.ViewModel) {
        DispatchQueue.main.async {
            viewModel.item.isLoadingImage = false
            viewModel.item.cellInterface?.setIsLoadingImage(isLoading: false)
        }
    }
    
    func displayImage(viewModel: ExploreModels.ImagePresentation.ViewModel) {
        DispatchQueue.main.async {
            viewModel.item.image = viewModel.image
            viewModel.item.imageContentMode = viewModel.contentMode
            viewModel.item.cellInterface?.setImage(image: viewModel.image, contentMode: viewModel.contentMode)
        }
    }
}
