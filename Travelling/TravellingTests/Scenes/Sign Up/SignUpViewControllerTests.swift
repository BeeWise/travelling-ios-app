//
//  SignUpViewControllerTests.swift
//  Travelling
//
//  Created by Dimitri Strauneanu on 06/10/2020.
//  Copyright (c) 2020 Travelling. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import Travelling
import XCTest

class SignUpViewControllerTests: XCTestCase {
    var sut: SignUpViewController!
    var interactorSpy: SignUpBusinessLogicSpy!
    var routerSpy: SignUpRoutingLogicSpy!
    var delegateSpy: SignUpViewControllerDelegateSpy!
    var window: UIWindow!
    
    // MARK: - Test lifecycle
    
    override func setUp() {
        super.setUp()
        self.window = UIWindow()
        self.setupSignUpViewController()
    }
    
    override func tearDown() {
        self.window = nil
        super.tearDown()
    }
    
    // MARK: - Test setup
    
    func setupSignUpViewController() {
        self.sut = SignUpViewController()
        let _ = UINavigationController(rootViewController: self.sut)
        
        self.interactorSpy = SignUpBusinessLogicSpy()
        self.sut.interactor = self.interactorSpy
        
        self.routerSpy = SignUpRoutingLogicSpy()
        self.sut.router = self.routerSpy
        
        self.delegateSpy = SignUpViewControllerDelegateSpy()
        self.sut.delegate = self.delegateSpy
    }
    
    func loadView() {
        self.window.addSubview(self.sut.view)
        RunLoop.current.run(until: Date())
    }
    
    func waitForMainQueue() {
        let waitExpectation = expectation(description: "Waiting for main queue.")
        DispatchQueue.main.async {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    // MARK: - Tests
    
    func testRevealNavigationBarWhenViewWillAppear() {
        self.sut.navigationController?.setNavigationBarHidden(true, animated: false)
        self.sut.viewWillAppear(true)
        XCTAssertNotNil(self.sut.navigationController)
        if let navigationController = self.sut.navigationController {
            XCTAssertFalse(navigationController.isNavigationBarHidden)
        }
    }
    
    func testShouldSetupItemsWhenTheViewDidLoad() {
        self.loadView()
        XCTAssertTrue(self.interactorSpy.shouldSetupItemsCalled)
    }
    
    // MARK: - Table view tests
    
    func testNumberOfRowsInAnySectionShouldEqualItemCount() {
        self.sut.displayedItems = [SignUpModels.Item(type: .email, model: nil)]
        let numberOfRows = self.sut.tableView(self.sut.tableView, numberOfRowsInSection: 0)
        XCTAssertEqual(numberOfRows, self.sut.displayedItems.count)
    }
    
    func testNumberOfSectionsInTableViewShouldAlwaysBeOne() {
        let tableView = self.sut.tableView
        let numberOfSections = self.sut.numberOfSections(in: tableView!)
        XCTAssertEqual(numberOfSections, 1)
    }
    
    func testCellForRowShouldReturnCorrectCellForItemType() {
        self.sut.displayedItems = [
            SignUpModels.Item(type: .email, model: SignUpModels.DisplayedTextItem()), SignUpModels.Item(type: .username, model: SignUpModels.DisplayedTextItem()),
            SignUpModels.Item(type: .password, model: SignUpModels.DisplayedTextItem()), SignUpModels.Item(type: .firstName, model: SignUpModels.DisplayedTextItem()),
            SignUpModels.Item(type: .lastName, model: SignUpModels.DisplayedTextItem()), SignUpModels.Item(type: .description, model: SignUpModels.DisplayedTextItem()),
            SignUpModels.Item(type: .photo, model: SignUpModels.DisplayedImageItem()), SignUpModels.Item(type: .signUp, model: SignUpModels.DisplayedButtonItem())
        ]
        
        let tableView = self.sut.tableView
        
        let emailCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 0, section: 0))
        let usernameCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 1, section: 0))
        let passwordCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 2, section: 0))
        let firstNameCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 3, section: 0))
        let lastNameCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 4, section: 0))
        let descriptionCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 5, section: 0))
        let photoCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 6, section: 0))
        let signUpCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 7, section: 0))
        
        XCTAssertTrue(emailCell is SignUpTextFieldCell)
        XCTAssertTrue(usernameCell is SignUpTextFieldCell)
        XCTAssertTrue(passwordCell is SignUpTextFieldCell)
        XCTAssertTrue(firstNameCell is SignUpTextFieldCell)
        XCTAssertTrue(lastNameCell is SignUpTextFieldCell)
        
        XCTAssertTrue(descriptionCell is SignUpTextViewCell)
        
        XCTAssertTrue(photoCell is SignUpPhotoCell)
        
        XCTAssertTrue(signUpCell is SignUpButtonCell)
    }
    
    func testShouldConfigureTextFieldCellToDisplayItems() {
        let displayedItems = [self.emailItem(), self.usernameItem(), self.passwordItem(), self.firstNameItem(), self.lastNameItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! SignUpTextFieldCell
            
            guard let model = item.model as? SignUpModels.DisplayedTextItem else {
                return XCTAssertTrue(false, "The model must be displayed text item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.titleTextFieldView.titleLabel?.attributedText?.string, model.title)
            XCTAssertEqual(cell.titleTextFieldView.textField?.attributedText?.string, model.text)
            XCTAssertEqual(cell.titleTextFieldView.textField?.attributedPlaceholder?.string, model.placeholder)
            XCTAssertEqual(cell.titleTextFieldView.errorLabel?.attributedText?.string, model.errorText)
            XCTAssertEqual(cell.titleTextFieldView.errorLabel?.isHidden, !model.displayError)
            XCTAssertEqual(cell.titleTextFieldView.textField?.keyboardType, model.keyboardType)
            XCTAssertEqual(cell.titleTextFieldView.textField?.autocapitalizationType, model.autocapitalizationType)
            XCTAssertEqual(cell.titleTextFieldView.textField?.autocorrectionType, model.autocorrectionType)
            XCTAssertEqual(cell.titleTextFieldView.textField?.returnKeyType, model.returnKeyType)
            XCTAssertEqual(cell.titleTextFieldView.textField?.isSecureTextEntry, model.isSecureText)
            XCTAssertEqual(cell.titleTextFieldView.maximumLength, model.maximumLength)
            XCTAssertNotNil(cell.delegate)
            XCTAssertNotNil(cell.titleTextFieldView.delegate)
            
            XCTAssertEqual(self.sut.textFields[index].1, item.type)
            XCTAssertEqual(self.sut.textFields[index].0, cell.titleTextFieldView.textField)
        }
    }
    
    private func emailItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "Email"
        model.placeholder = "Email"
        model.keyboardType = .emailAddress
        model.autocapitalizationType = .none
        model.autocorrectionType = .no
        model.errorText = "Wrong email."
        model.displayError = true
        return SignUpModels.Item(type: SignUpModels.ItemType.email, model: model)
    }
    
    private func usernameItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "Username"
        model.placeholder = "Username"
        model.errorText = "Wrong username."
        model.displayError = true
        return SignUpModels.Item(type: SignUpModels.ItemType.username, model: model)
    }
    
    private func passwordItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "Password"
        model.placeholder = "Password"
        model.isSecureText = true
        model.errorText = "Wrong password."
        model.displayError = true
        return SignUpModels.Item(type: SignUpModels.ItemType.password, model: model)
    }
    
    private func firstNameItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "First name"
        model.placeholder = "First name"
        model.autocapitalizationType = .words
        model.autocorrectionType = .yes
        model.errorText = "Wrong first name."
        return SignUpModels.Item(type: SignUpModels.ItemType.firstName, model: model)
    }
    
    private func lastNameItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "Last name"
        model.placeholder = "Last name"
        model.autocapitalizationType = .words
        model.autocorrectionType = .yes
        model.errorText = "Wrong last name."
        return SignUpModels.Item(type: SignUpModels.ItemType.lastName, model: model)
    }
    
    func testShouldConfigureTextViewCellToDisplayItems() {
        let displayedItems = [self.descriptionItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! SignUpTextViewCell
            
            guard let model = item.model as? SignUpModels.DisplayedTextItem else {
                return XCTAssertTrue(false, "The model must be displayed text item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.titleTextView.titleLabel?.attributedText?.string, model.title)
            XCTAssertEqual(cell.titleTextView.textView?.attributedText.string, model.text)
            XCTAssertEqual(cell.titleTextView.textView?.attributedPlaceholder?.string, model.placeholder)
            XCTAssertEqual(cell.titleTextView.errorLabel?.attributedText?.string, model.errorText)
            XCTAssertEqual(cell.titleTextView.errorLabel?.isHidden, !model.displayError)
            XCTAssertEqual(cell.titleTextView.textView?.keyboardType, model.keyboardType)
            XCTAssertEqual(cell.titleTextView.textView.autocapitalizationType, model.autocapitalizationType)
            XCTAssertEqual(cell.titleTextView.textView.autocorrectionType, model.autocorrectionType)
            XCTAssertEqual(cell.titleTextView.maximumLength, model.maximumLength)
            XCTAssertNotNil(cell.delegate)
            XCTAssertNotNil(cell.titleTextView.delegate)
        }
    }
    
    private func descriptionItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedTextItem()
        model.title = "Description"
        model.placeholder = "Description"
        model.keyboardType = .alphabet
        model.autocapitalizationType = .sentences
        model.autocorrectionType = .yes
        return SignUpModels.Item(type: SignUpModels.ItemType.description, model: model)
    }
    
    func testShouldConfigurePhotoCellToDisplayItems() {
        let displayedItems = [self.photoItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! SignUpPhotoCell
            
            guard let model = item.model as? SignUpModels.DisplayedImageItem else {
                return XCTAssertTrue(false, "The model must be displayed image item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.photoImageView?.image, model.image)
            XCTAssertNotNil(cell.delegate)
        }
    }
    
    private func photoItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedImageItem()
        model.image = UIImage()
        return SignUpModels.Item(type: SignUpModels.ItemType.photo, model: model)
    }
    
    func testShouldConfigureButtonCellToDisplayItems() {
        let displayedItems = [self.signUpItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! SignUpButtonCell
            
            guard let model = item.model as? SignUpModels.DisplayedButtonItem else {
                return XCTAssertTrue(false, "The model must be displayed button item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.button?.currentAttributedTitle, model.title)
            XCTAssertEqual(cell.button?.isEnabled, model.isEnabled)
            XCTAssertNotNil(cell.delegate)
        }
    }
    
    private func signUpItem() -> SignUpModels.Item {
        let model = SignUpModels.DisplayedButtonItem()
        model.title = "Sign Up".attributed(attributes: [NSAttributedString.Key.foregroundColor: UIColor.black])
        model.isEnabled = true
        return SignUpModels.Item(type: SignUpModels.ItemType.signUp, model: model)
    }
    
    func testDisplaySetupItems() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let displayedItems: [SignUpModels.Item] = [SignUpModels.Item(type: .email, model: nil)]
        let viewModel = SignUpModels.SetupItems.ViewModel(displayedItems: displayedItems)
        self.sut.displaySetupItems(viewModel: viewModel)
        self.waitForMainQueue()
        
        XCTAssertEqual(displayedItems.count, self.sut.displayedItems.count)
        XCTAssertTrue(displayedItems.elementsEqual(self.sut.displayedItems, by: { $0 == $1 }))
        XCTAssertTrue(tableViewSpy.reloadDataCalled)
    }
    
    // MARK: - Business logic tests
    
    func testShouldUpdateItemWhenTextFieldEditingChanged() {
        self.sut.signUpTextFieldCell(cell: nil, textFieldEditingChanged: nil, text: "email", itemType: SignUpModels.ItemType.email)
        XCTAssertTrue(self.interactorSpy.shouldUpdateItemCalled)
    }
    
    func testShouldValidateItemWhenTextFieldEditingEnded() {
        self.sut.signUpTextFieldCell(cell: nil, textFieldDidEndEditing: nil, itemType: SignUpModels.ItemType.email)
        XCTAssertTrue(self.interactorSpy.shouldValidateItemCalled)
    }
    
    func testShouldUpdateItemWhenTextViewEditingChanged() {
        self.sut.signUpTextViewCell(cell: nil, textViewEditingChanged: nil, text: "description", itemType: SignUpModels.ItemType.description)
        XCTAssertTrue(self.interactorSpy.shouldUpdateItemCalled)
    }
    
    func testShouldValidateItemWhenTextViewEditingEnded() {
        self.sut.signUpTextViewCell(cell: nil, textViewDidEndEditing: nil, itemType: SignUpModels.ItemType.description)
        XCTAssertTrue(self.interactorSpy.shouldValidateItemCalled)
    }
    
    func testShouldActivateTextFieldForItemWhenTextFieldShouldReturn() {
        self.sut.displayedItems = [SignUpModels.Item(type: .email, model: nil), SignUpModels.Item(type: .username, model: nil)]
        let _ = self.sut.signUpTextFieldCell(cell: nil, textFieldShouldReturn: nil, itemType: SignUpModels.ItemType.email)
        XCTAssertTrue(self.interactorSpy.shouldActivateTextFieldCalled)
    }
    
    func testShouldSelectItemWhenUploadPhotoButtonIsSelected() {
        self.sut.signUpPhotoCell(cell: nil, didSelect: UIButton(), itemType: SignUpModels.ItemType.photo)
        XCTAssertTrue(self.interactorSpy.shouldSelectItemCalled)
    }
    
    func testShouldUpdateImageItemWhenImagePickerControllerDidFinishPickingMedia() {
        self.sut.imagePickerController(UIImagePickerController(), didFinishPickingMediaWithInfo: [UIImagePickerController.InfoKey.originalImage: UIImage()])
        XCTAssertTrue(self.interactorSpy.shouldUpdateImageItemCalled)
    }
    
    func testShouldSelectItemWhenSignUpButtonIsTouchedUpInside() {
        self.sut.signUpButtonCell(cell: nil, didSelect: UIButton(), itemType: SignUpModels.ItemType.signUp)
        XCTAssertTrue(self.interactorSpy.shouldSelectItemCalled)
    }
    
    // MARK: - Display logic tests
    
    func testDisplayUpdateItem() {
        let model = SignUpModels.DisplayedTextItem()
        model.text = "old.email"
        self.sut.displayedItems = [SignUpModels.Item(type: SignUpModels.ItemType.email, model: model)]
        
        let email = "new.email"
        let viewModel = SignUpModels.UpdateItem.ViewModel(text: email, type: SignUpModels.ItemType.email)
        self.sut.displayUpdateItem(viewModel: viewModel)
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.email) as? SignUpModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The model must be displayed text item!")
        }
        XCTAssertEqual(textModel.text, email)
    }
    
    func testDisplayValidationErrorWhenThereIsNoErrorPresent() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedTextItem()
        model.displayError = false
        self.sut.displayedItems = [SignUpModels.Item(type: SignUpModels.ItemType.email, model: model)]
        
        let displayError = true
        let viewModel = SignUpModels.ValidateItem.ViewModel(type: SignUpModels.ItemType.email, displayError: displayError)
        self.sut.displayValidationError(viewModel: viewModel)
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.email) as? SignUpModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The model must be displayed text item!")
        }
        XCTAssertEqual(textModel.displayError, displayError)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayValidationErrorWhenThereIsErrorPresent() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedTextItem()
        model.displayError = true
        self.sut.displayedItems = [SignUpModels.Item(type: SignUpModels.ItemType.email, model: model)]
        
        let displayError = false
        let viewModel = SignUpModels.ValidateItem.ViewModel(type: SignUpModels.ItemType.email, displayError: displayError)
        self.sut.displayValidationError(viewModel: viewModel)
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.email) as? SignUpModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The model must be displayed text item!")
        }
        XCTAssertEqual(textModel.displayError, displayError)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayEnableItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedButtonItem()
        model.isEnabled = false
        self.sut.displayedItems = [SignUpModels.Item(type: SignUpModels.ItemType.signUp, model: model)]
        
        self.sut.displayEnableItem(viewModel: SignUpModels.EnableItem.ViewModel(type: SignUpModels.ItemType.signUp))
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.signUp) as? SignUpModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isEnabled, true)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayDisableItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedButtonItem()
        model.isEnabled = true
        self.sut.displayedItems = [SignUpModels.Item(type: SignUpModels.ItemType.signUp, model: model)]
        
        self.sut.displayDisableItem(viewModel: SignUpModels.EnableItem.ViewModel(type: SignUpModels.ItemType.signUp))
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.signUp) as? SignUpModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isEnabled, false)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayPhotoLibraryAlert() {
        let viewModel = SignUpModels.PhotoLibraryAlert.ViewModel(photoLibraryTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayPhotoLibraryAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayPhotoLibraryCameraAlert() {
        let viewModel = SignUpModels.PhotoLibraryCameraAlert.ViewModel(photoLibraryTitle: "title", cameraTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayPhotoLibraryCameraAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayPhotoLibraryRemovePhotoAlert() {
        let viewModel = SignUpModels.PhotoLibraryRemovePhotoAlert.ViewModel(photoLibraryTitle: "title", removePhotoTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayPhotoLibraryRemovePhotoAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayPhotoLibraryCameraRemovePhotoAlert() {
        let viewModel = SignUpModels.PhotoLibraryCameraRemovePhotoAlert.ViewModel(photoLibraryTitle: "title", cameraTitle: "title", removePhotoTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayPhotoLibraryCameraRemovePhotoAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayCameraAlert() {
        let viewModel = SignUpModels.CameraAlert.ViewModel(cameraTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayCameraAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayCameraRemovePhotoAlert() {
        let viewModel = SignUpModels.CameraRemovePhotoAlert.ViewModel(cameraTitle: "title", removePhotoTitle: "title", cancelTitle: "cancel", sourceView: UIView())
        self.sut.displayCameraRemovePhotoAlert(viewModel: viewModel)
        XCTAssertTrue(self.routerSpy.navigateToActionSheetCalled)
    }
    
    func testDisplayNavigateToPhotoLibrary() {
        self.sut.displayNavigateToPhotoLibrary(viewModel: SignUpModels.SourceView.ViewModel(sourceView: UIView()))
        XCTAssertTrue(self.routerSpy.navigateToPhotoLibraryCalled)
    }
    
    func testDisplayNavigateToCamera() {
        self.sut.displayNavigateToCamera(viewModel: SignUpModels.SourceView.ViewModel(sourceView: UIView()))
        XCTAssertTrue(self.routerSpy.navigateToCameraCalled)
    }
    
    func testDismissViewControllerWhenImagePickerControllerDidCancel() {
        self.sut.imagePickerControllerDidCancel(UIImagePickerController())
        XCTAssertTrue(self.routerSpy.dismissViewControllerCalled)
    }
    
    func testDismissViewControllerWhenImagePickerControllerDidFinishPickingMedia() {
        self.sut.imagePickerController(UIImagePickerController(), didFinishPickingMediaWithInfo: [:])
        XCTAssertTrue(self.routerSpy.dismissViewControllerCalled)
    }
    
    func testDisplayUpdateImageItemWhenThereIsNoPhoto() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedImageItem()
        model.image = nil
        self.sut.displayedItems = [SignUpModels.Item(type: .photo, model: model)]
        
        let image = UIImage()
        self.sut.displayUpdateImageItem(viewModel: SignUpModels.UpdateImageItem.ViewModel(image: image, contentMode: .scaleAspectFill, type: SignUpModels.ItemType.photo))
        self.waitForMainQueue()
        
        guard let imageModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.photo) as? SignUpModels.DisplayedImageItem else {
            return XCTAssertTrue(false, "The model must be displayed image item!")
        }
        XCTAssertEqual(imageModel.image, image)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayUpdateImageItemWhenThereIsPhoto() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedImageItem()
        model.image = UIImage()
        model.contentMode = .scaleToFill
        self.sut.displayedItems = [SignUpModels.Item(type: .photo, model: model)]
        
        self.sut.displayUpdateImageItem(viewModel: SignUpModels.UpdateImageItem.ViewModel(image: nil, contentMode: .center, type: SignUpModels.ItemType.photo))
        
        self.waitForMainQueue()
        
        guard let imageModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.photo) as? SignUpModels.DisplayedImageItem else {
            return XCTAssertTrue(false, "The model must be displayed image item!")
        }
        XCTAssertNil(imageModel.image)
        XCTAssertEqual(imageModel.contentMode, .center)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayLoadingItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedButtonItem()
        model.isLoading = false
        self.sut.displayedItems = [SignUpModels.Item(type: .signUp, model: model)]
        
        self.sut.displayLoadingItem(viewModel: SignUpModels.LoadingItem.ViewModel(type: SignUpModels.ItemType.signUp))
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.signUp) as? SignUpModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isLoading, true)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayNotLoadingItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = SignUpModels.DisplayedButtonItem()
        model.isLoading = true
        self.sut.displayedItems = [SignUpModels.Item(type: .signUp, model: model)]
        
        self.sut.displayNotLoadingItem(viewModel: SignUpModels.LoadingItem.ViewModel(type: SignUpModels.ItemType.signUp))
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItemModel(type: SignUpModels.ItemType.signUp) as? SignUpModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isLoading, false)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayEnableUserInteraction() {
        let tableViewSpy = UITableViewSpy()
        tableViewSpy.isUserInteractionEnabled = false
        self.sut.tableView = tableViewSpy
        self.sut.displayEnableUserInteraction()
        self.waitForMainQueue()
        XCTAssertTrue(tableViewSpy.isUserInteractionEnabled)
    }
    
    func testDisplayDisableUserInteraction() {
        let tableViewSpy = UITableViewSpy()
        tableViewSpy.isUserInteractionEnabled = true
        self.sut.tableView = tableViewSpy
        self.sut.displayDisableUserInteraction()
        self.waitForMainQueue()
        XCTAssertFalse(tableViewSpy.isUserInteractionEnabled)
    }
    
    func testDisplayUserDetails() {
        let user = User(id: "userId")
        self.sut.displayUserDetails(viewModel: SignUpModels.SignUpUser.ViewModel(user: user))
        self.waitForMainQueue()
        XCTAssertTrue(self.delegateSpy.signUpViewControllerDidSignUpUserCalled)
    }
    
    func testDisplayErrorDetails() {
        self.sut.displayErrorDetails(viewModel: SignUpModels.SignUpError.ViewModel(message: "message", okTitle: "ok"))
        self.waitForMainQueue()
        XCTAssertTrue(self.routerSpy.navigateToAlertCalled)
    }
}

func ==(lhs: SignUpModels.Item, rhs: SignUpModels.Item) -> Bool {
    return lhs.type == rhs.type
}
