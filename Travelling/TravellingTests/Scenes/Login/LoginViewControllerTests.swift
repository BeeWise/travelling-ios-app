//
//  LoginViewControllerTests.swift
//  Travelling
//
//  Created by Dimitri Strauneanu on 04/10/2020.
//  Copyright (c) 2020 Travelling. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import Travelling
import XCTest

class LoginViewControllerTests: XCTestCase {
    var sut: LoginViewController!
    var interactorSpy: LoginBusinessLogicSpy!
    var routerSpy: LoginRoutingLogicSpy!
    var delegateSpy: LoginViewControllerDelegateSpy!
    var window: UIWindow!
    
    // MARK: - Test lifecycle
    
    override func setUp() {
        super.setUp()
        self.window = UIWindow()
        self.setupLoginViewController()
    }
    
    override func tearDown() {
        self.window = nil
        super.tearDown()
    }
    
    // MARK: - Test setup
    
    func setupLoginViewController() {
        self.sut = LoginViewController()
        let _ = UINavigationController(rootViewController: self.sut)
        
        self.interactorSpy = LoginBusinessLogicSpy()
        self.sut.interactor = self.interactorSpy
        
        self.routerSpy = LoginRoutingLogicSpy()
        self.sut.router = self.routerSpy
        
        self.delegateSpy = LoginViewControllerDelegateSpy()
        self.sut.delegate = self.delegateSpy
    }
    
    func loadView() {
        self.window.addSubview(self.sut.view)
        RunLoop.current.run(until: Date())
    }
    
    func waitForMainQueue() {
        let waitExpectation = expectation(description: "Waiting for main queue.")
        DispatchQueue.main.async {
            waitExpectation.fulfill()
        }
        waitForExpectations(timeout: 1.0)
    }
    
    // MARK: - Tests
    
    func testRevealNavigationBarWhenViewWillAppear() {
        self.sut.navigationController?.setNavigationBarHidden(true, animated: false)
        
        self.sut.viewWillAppear(true)
        
        XCTAssertNotNil(self.sut.navigationController)
        if let navigationController = self.sut.navigationController {
            XCTAssertFalse(navigationController.isNavigationBarHidden)
        }
    }
    
    // MARK: - Table view tests
    
    func testNumberOfRowsInAnySectionShouldEqualItemCount() {
        self.sut.displayedItems = [LoginModels.Item(type: .account, model: nil)]
        let numberOfRows = self.sut.tableView(self.sut.tableView, numberOfRowsInSection: 0)
        XCTAssertEqual(numberOfRows, self.sut.displayedItems.count)
    }
    
    func testNumberOfSectionsInTableViewShouldAlwaysBeOne() {
        let tableView = self.sut.tableView
        let numberOfSections = self.sut.numberOfSections(in: tableView!)
        XCTAssertEqual(numberOfSections, 1)
    }
    
    func testCellForRowShouldReturnCorrectCellForItemType() {
        self.sut.displayedItems = [
            LoginModels.Item(type: .account, model: nil), LoginModels.Item(type: .password, model: nil),
            LoginModels.Item(type: .forgotPassword, model: nil), LoginModels.Item(type: .login, model: nil)
        ]
        
        let tableView = self.sut.tableView
        
        let accountCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 0, section: 0))
        let passwordCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 1, section: 0))
        let forgotPasswordCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 2, section: 0))
        let loginCell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: 3, section: 0))
        
        XCTAssertTrue(accountCell is LoginTextFieldCell)
        XCTAssertTrue(passwordCell is LoginTextFieldCell)
        XCTAssertTrue(forgotPasswordCell is LoginForgotPasswordButtonCell)
        XCTAssertTrue(loginCell is LoginButtonCell)
    }
    
    func testShouldConfigureTextFieldCellToDisplayItems() {
        let displayedItems = [self.accountItem(), self.passwordItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! LoginTextFieldCell
            
            guard let model = item.model as? LoginModels.DisplayedTextItem else {
                return XCTAssertTrue(false, "The item model must be displayed text item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.titleTextFieldView.titleLabel?.attributedText?.string, model.title)
            XCTAssertEqual(cell.titleTextFieldView.textField?.attributedText?.string, model.text)
            XCTAssertEqual(cell.titleTextFieldView.textField?.attributedPlaceholder?.string, model.placeholder)
            XCTAssertEqual(cell.titleTextFieldView.errorLabel?.attributedText?.string, model.errorText)
            XCTAssertEqual(cell.titleTextFieldView.errorLabel?.isHidden, !model.displayError)
            XCTAssertEqual(cell.titleTextFieldView.textField?.keyboardType, model.keyboardType)
            XCTAssertEqual(cell.titleTextFieldView.textField.autocapitalizationType, model.autocapitalizationType)
            XCTAssertEqual(cell.titleTextFieldView.textField.autocorrectionType, model.autocorrectionType)
            XCTAssertEqual(cell.titleTextFieldView.textField?.isSecureTextEntry, model.isSecureText)
            XCTAssertEqual(cell.titleTextFieldView.textField?.returnKeyType, model.returnKeyType)
            XCTAssertNotNil(cell.delegate)
            XCTAssertNotNil(cell.titleTextFieldView.delegate)
            
            XCTAssertEqual(self.sut.textFields[index].1, item.type)
            XCTAssertEqual(self.sut.textFields[index].0, cell.titleTextFieldView.textField)
        }
    }
    
    private func accountItem() -> LoginModels.Item {
        let model = LoginModels.DisplayedTextItem()
        model.title = "Email or username"
        model.placeholder = "Email or username"
        model.keyboardType = .emailAddress
        model.autocapitalizationType = .none
        model.autocorrectionType = .no
        model.returnKeyType = .next
        model.errorText = "Wrong email or username"
        model.displayError = false
        return LoginModels.Item(type: .account, model: model)
    }
    
    private func passwordItem() -> LoginModels.Item {
        let model = LoginModels.DisplayedTextItem()
        model.placeholder = "Password"
        model.autocapitalizationType = .none
        model.autocorrectionType = .no
        model.isSecureText = true
        model.returnKeyType = .done
        model.errorText = "Wrong password."
        model.displayError = true
        return LoginModels.Item(type: .password, model: model)
    }
    
    func testShouldConfigureButtonCell() {
        let displayedItems = [self.loginItem()]
        let tableView = self.sut.tableView
        
        self.sut.displayedItems = displayedItems
        
        displayedItems.enumerated().forEach { (index, item) in
            let cell = self.sut.tableView(tableView!, cellForRowAt: IndexPath(row: index, section: 0)) as! LoginButtonCell
            
            guard let model = item.model as? LoginModels.DisplayedButtonItem else {
                return XCTAssertTrue(false, "The item model must be displayed button item!")
            }
            
            XCTAssertEqual(cell.itemType, item.type)
            XCTAssertEqual(cell.button?.currentAttributedTitle, model.title)
            XCTAssertEqual(cell.button?.isEnabled, model.isEnabled)
            XCTAssertNotNil(cell.delegate)
        }
    }
    
    private func loginItem() -> LoginModels.Item {
        let model = LoginModels.DisplayedButtonItem()
        model.title = "Login".attributed(attributes: [NSAttributedString.Key.foregroundColor: UIColor.black])
        model.isEnabled = false
        return LoginModels.Item(type: .login, model: model)
    }
    
    // MARK: - Business logic tests
    
    func testShouldSetupItemsWhenTheViewDidLoad() {
        self.loadView()
        XCTAssertTrue(self.interactorSpy.shouldSetupItemsCalled)
    }
    
    func testShouldUpdateItemWhenTextFieldEditingChanged() {
        self.sut.loginTextFieldCell(cell: nil, textFieldEditingChanged: nil, text: "email or username", itemType: LoginModels.ItemType.account)
        XCTAssertTrue(self.interactorSpy.shouldUpdateItemCalled)
    }
    
    func testShouldValidateItemWhenTextFieldEditingEnded() {
        self.sut.loginTextFieldCell(cell: nil, textFieldDidEndEditing: nil, itemType: LoginModels.ItemType.account)
        XCTAssertTrue(self.interactorSpy.shouldValidateItemCalled)
    }
    
    func testShouldActivateTextFieldForItemWhenTextFieldShouldReturn() {
        self.sut.displayedItems = [LoginModels.Item(type: .account, model: nil), LoginModels.Item(type: .password, model: nil)]
        
        let _ = self.sut.loginTextFieldCell(cell: nil, textFieldShouldReturn: nil, itemType: LoginModels.ItemType.account)
        XCTAssertTrue(self.interactorSpy.shouldActivateTextFieldCalled)
    }
    
    func testShouldSelectItemWhenLoginButtonIsTouchedUpInside() {
        self.sut.loginButtonCell(cell: nil, didSelect: nil, itemType: LoginModels.ItemType.login)
        XCTAssertTrue(self.interactorSpy.shouldSelectItemCalled)
    }
    
    func testShouldSelectItemWhenForgotPasswordButtonIsTouchedUpInside() {
        self.sut.loginForgotPasswordButtonCell(cell: nil, didSelect: nil, itemType: LoginModels.ItemType.forgotPassword)
        XCTAssertTrue(self.interactorSpy.shouldSelectItemCalled)
    }
    
    // MARK: - Display logic tests
    
    func testDisplaySetupItems() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let displayedItems: [LoginModels.Item] = [LoginModels.Item(type: .account, model: nil)]
        let viewModel = LoginModels.SetupItems.ViewModel(displayedItems: displayedItems)
        self.sut.displaySetupItems(viewModel: viewModel)
        
        self.waitForMainQueue()
        
        XCTAssertEqual(displayedItems.count, self.sut.displayedItems.count)
        XCTAssertTrue(displayedItems.elementsEqual(self.sut.displayedItems, by: { $0 == $1 }))
        
        XCTAssertTrue(tableViewSpy.reloadDataCalled)
    }
        
    func testDisplayUpdateItem() {
        let model = LoginModels.DisplayedTextItem()
        model.text = "old.account"
        self.sut.displayedItems = [LoginModels.Item(type: LoginModels.ItemType.account, model: model)]
        
        let email = "new.account"
        let viewModel = LoginModels.UpdateItem.ViewModel(text: email, type: LoginModels.ItemType.account)
        self.sut.displayUpdateItem(viewModel: viewModel)
        
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItems.first(where: { $0.type == .account })?.model as? LoginModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The item model must be displayed text item!")
        }
        XCTAssertEqual(textModel.text, email)
    }
    
    func testDisplayValidationErrorWhenThereIsNoErrorPresent() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedTextItem()
        model.displayError = false
        self.sut.displayedItems = [LoginModels.Item(type: LoginModels.ItemType.account, model: model)]
        
        let displayError = true
        let viewModel = LoginModels.ValidateItem.ViewModel(type: LoginModels.ItemType.account, displayError: displayError)
        self.sut.displayValidationError(viewModel: viewModel)
        
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItems.first(where: { $0.type == .account })?.model as? LoginModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The item model must be displayed text item!")
        }
        XCTAssertEqual(textModel.displayError, displayError)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayValidationErrorWhenThereIsErrorPresent() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedTextItem()
        model.displayError = true
        self.sut.displayedItems = [LoginModels.Item(type: LoginModels.ItemType.account, model: model)]
        
        let displayError = false
        let viewModel = LoginModels.ValidateItem.ViewModel(type: LoginModels.ItemType.account, displayError: displayError)
        self.sut.displayValidationError(viewModel: viewModel)
        
        self.waitForMainQueue()
        
        guard let textModel = self.sut.displayedItems.first(where: { $0.type == .account })?.model as? LoginModels.DisplayedTextItem else {
            return XCTAssertTrue(false, "The item model must be displayed text item!")
        }
        XCTAssertEqual(textModel.displayError, displayError)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayEnableItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedButtonItem()
        model.isEnabled = false
        self.sut.displayedItems = [LoginModels.Item(type: LoginModels.ItemType.login, model: model)]
        
        self.sut.displayEnableItem(viewModel: LoginModels.EnableItem.ViewModel(type: LoginModels.ItemType.login))
        
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItems.first(where: { $0.type == .login })?.model as? LoginModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The item model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isEnabled, true)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayDisableItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedButtonItem()
        model.isEnabled = true
        self.sut.displayedItems = [LoginModels.Item(type: LoginModels.ItemType.login, model: model)]
        
        self.sut.displayDisableItem(viewModel: LoginModels.EnableItem.ViewModel(type: LoginModels.ItemType.login))
        
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItems.first(where: { $0.type == .login })?.model as? LoginModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The item model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isEnabled, false)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayLoadingItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedButtonItem()
        model.isLoading = false
        self.sut.displayedItems = [LoginModels.Item(type: .login, model: model)]
        
        self.sut.displayLoadingItem(viewModel: LoginModels.LoadingItem.ViewModel(type: LoginModels.ItemType.login))
        
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItems.first(where: { $0.type == .login })?.model as? LoginModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The item model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isLoading, true)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayNotLoadingItem() {
        let tableViewSpy = UITableViewSpy()
        self.sut.tableView = tableViewSpy
        
        let model = LoginModels.DisplayedButtonItem()
        model.isLoading = true
        self.sut.displayedItems = [LoginModels.Item(type: .login, model: model)]
        
        self.sut.displayNotLoadingItem(viewModel: LoginModels.LoadingItem.ViewModel(type: LoginModels.ItemType.login))
        
        self.waitForMainQueue()
        
        guard let buttonModel = self.sut.displayedItems.first(where: { $0.type == .login })?.model as? LoginModels.DisplayedButtonItem else {
            return XCTAssertTrue(false, "The item model must be displayed button item!")
        }
        XCTAssertEqual(buttonModel.isLoading, false)
        XCTAssertTrue(tableViewSpy.reloadRowsCalled)
    }
    
    func testDisplayEnableUserInteraction() {
        let tableViewSpy = UITableViewSpy()
        tableViewSpy.isUserInteractionEnabled = false
        self.sut.tableView = tableViewSpy
        
        self.sut.displayEnableUserInteraction()
        self.waitForMainQueue()
        XCTAssertTrue(tableViewSpy.isUserInteractionEnabled)
    }
    
    func testDisplayDisableUserInteraction() {
        let tableViewSpy = UITableViewSpy()
        tableViewSpy.isUserInteractionEnabled = true
        self.sut.tableView = tableViewSpy
        
        self.sut.displayDisableUserInteraction()
        self.waitForMainQueue()
        XCTAssertFalse(tableViewSpy.isUserInteractionEnabled)
    }
    
    func testDisplayErrorAlert() {
        let viewModel = LoginModels.LoginError.ViewModel(message: "Error", okTitle: "OK")
        self.sut.displayErrorAlert(viewModel: viewModel)
        self.waitForMainQueue()
        XCTAssertTrue(routerSpy.navigateToAlertCalled)
    }
    
    func testDisplayUserDetails() {
        let user = User(id: "userId")
        self.sut.displayUserDetails(viewModel: LoginModels.UserDetails.ViewModel(user: user))
        self.waitForMainQueue()
        XCTAssertTrue(self.delegateSpy.loginViewControllerDidLoginUserCalled)
    }
}

func ==(lhs: LoginModels.Item, rhs: LoginModels.Item) -> Bool {
    return lhs.type == rhs.type
}
